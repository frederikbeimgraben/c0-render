#use "vector.c0"
#use "math.c0"
#use "geometry.c0"
#use <util>
#use <conio>
#use "drand.c0"

typedef struct Ray* ray;

struct Ray {
    vector origin;
    vector direction;
};

ray Ray(vector o, vector d) {
    ray result = alloc(struct Ray);
    result->origin = o;
    result->direction = d;
    return result;
}

vector point_at_param(ray r, double p) {
    return vadd(cprm(r->direction, p), r->origin);
}

// double dist_sphere(sphere s, ray r) {
//     vector center = s->pos; double radius = s->radius;
//     vector oc = vsub(r->origin, center);
//     double a = vector_dot(r->direction, r->direction);
//     double b = dmul(itod(2), vector_dot(oc, r->direction));
//     double c = dsub(vector_dot(oc, oc), pow_n(radius, 2));
//     double discr = dsub(pow_n(b, 2), dmul(dmul(itod(4), a), c));
//     if (dless(discr, itod(0)))
//         return itod(-1);
//     else
//         return (
//             ddiv(dsub(dsub(itod(0), b), sqrt(discr)), dmul(itod(2), a))
//         );
// }

bool hit_sphere(sphere s, ray r, double t_min, double t_max) {
    vector center = s->pos; double radius = s->radius;
    vector oc = vsub(r->origin, center);
    double a = vector_dot(r->direction, r->direction);
    double b = vector_dot(oc, r->direction);
    double c = dsub(vector_dot(oc, oc), dmul(radius, radius));
    double discr = dsub(pow_n(b, 2), dmul(a, c));
    if (dless(discr, itod(0))) {}
    else {
        double temp =  ddiv(dsub(dsub(itod(0), b), sqrt(dsub(pow_n(b, 2), dmul(a, c)))), a);
        if (dless(temp, t_max) && dless(t_min, temp)) {
            s->t = temp;
            s->p = point_at_param(r, temp);
            s->normal = cprm(vsub(s->p, s->pos), ddiv(itod(1), s->radius));
            return true;
        }
        temp = ddiv(dadd(dsub(itod(0), b), sqrt(dsub(pow_n(b, 2), dmul(a, c)))), a);
        if (dless(temp, t_max) && dless(t_min, temp)) {
            s->t = temp;
            s->p = point_at_param(r, temp);
            s->normal = cprm(vsub(s->p, s->pos), ddiv(itod(1), s->radius));
            return true;
        }
    }
    return false;
}

bool hit(ray r, double t_min, double t_max, sphere[] world, int sn, sphere* rec) {
    bool hit_anything = false;
    double closest = t_max;
    for (int i = 0; i < sn; i++) {
        if (hit_sphere(world[i], r, t_min, t_max)) {
            hit_anything = true;
            closest = world[i]->t;
            *rec = world[i];
        }
    }
    return hit_anything;
}

vector rand_in_usphere(rand_t gen) {
    vector p = iVector(1, 1, 1);
    while (true) {
        p = vsub(cprm(Vector(drand(gen), drand(gen), drand(gen)), itod(2)), iVector(1, 1, 1));
        if (! dless(itod(1), pow_n(vlen(p), 2)) ) {
            return p;
        }
    }
    return p;
}

vector global_lighting(ray r, vector light) {
    vector unit_dir = unit_vector(r->direction);
    double t = vector_dot(unit_dir, unit_vector(light));
    t = dless(itod(0), t) ? t : itod(0);
    t = dless(t, itod(1)) ? t : itod(1);
    vector c = vadd(
        cprm(
            Vector(dfloat(3, 1), dfloat(3, 1), dfloat(3, 1)),
            t
        ),
        cprm(
            iVector(1, 1, 1),
            dsub(itod(1), t)
        )
    );
    return iVector(
        dtoi(dmul(c->x, itod(255))),
        dtoi(dmul(c->y, itod(255))),
        dtoi(dmul(c->z, itod(255)))
    );
}



vector ray_color(ray r, sphere[] s, int sn, rand_t gen, bool trace, vector light, int depth) {
    sphere* rec = alloc(sphere);
    if (hit(r, dfloat(1, 3), itod(int_max()), s, sn, rec)) {
        vector target = (
            (*rec)->material == 0 ? 
               vadd(rand_in_usphere(gen), (*rec)->normal)
            : vadd(
                vsub(
                    unit_vector(r->direction), 
                    cprm(
                        (*rec)->normal, 
                        dmul(
                            itod(2), 
                            vector_dot(unit_vector(r->direction), (*rec)->normal)
                        )
                    )
                ),
                cprm(rand_in_usphere(gen), (*rec)->fuzz)
            )
        );
        // vector c = cprm(
        //     Vector(
        //         dadd((*rec)->normal->x, itod(1)),
        //         dadd((*rec)->normal->y, itod(1)),
        //         dadd((*rec)->normal->z, itod(1))
        //     ),
        //     dfloat(5, 1)
        // );
        // return Color(
        //     dtoi(dmul(c->x, itod((*rec)->c->r))),
        //     dtoi(dmul(c->y, itod((*rec)->c->g))),
        //     dtoi(dmul(c->z, itod((*rec)->c->b))),
        //     (*rec)->c->a
        // );
        if (depth < 30) 
            return TintVector(
                cprm(
                    ray_color(
                        Ray(
                            (*rec)->p,
                            target
                        ),
                        s,
                        sn,
                        gen,
                        (*rec)->material == 0,
                        light,
                        depth + 1
                    ),
                    (*rec)->a
                ),
                (*rec)->c
            );
        else {
            return global_lighting(r, light);
        }
    } else if (!trace) {
        vector unit_dir = unit_vector(r->direction);
        double t = dmul(dadd(unit_dir->y, itod(1)), dfloat(5, 1));
        vector c = vadd(
            cprm(
                iVector(1, 1, 1),
                t
            ),
            cprm(
                Vector(dfloat(5, 1), dfloat(7, 1), dfloat(1, 0)),
                dsub(itod(1), t)
            )
        );
        return iVector(
            dtoi(dmul(c->x, itod(255))),
            dtoi(dmul(c->y, itod(255))),
            dtoi(dmul(c->z, itod(255)))
        );
    } else {
        return global_lighting(r, light);
    }
}



color Trace(ray* r, int depth, object o) {
    double min_dist = itod(int_max());
    vector* pHit = alloc(vector);
    vector* nHit = alloc(vector);
    for (int k = 0; k < o->n; k++) {
        
    }
    return Color(255, 255, 255, 255);
}


